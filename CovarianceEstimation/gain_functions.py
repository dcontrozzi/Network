# -*- coding: utf-8 -*-"""Created on Sun Jun  6 11:02:30 2021@author: Guido Previde Massara"""import itertoolsfrom numba import njitimport numpy as npimport numpy as npfrom itertools import combinations# def greedy_sortsep(vtx, sep, W):##     w = W[vtx, sep]#     sepv = np.array(sep)#     sep_ranked = np.argsort(-w) #np.argsort(w)[::-1]##     return w[sep_ranked], sepv[sep_ranked]def greedy_sortsep(vtx, sep, W):    w = W[vtx, sep]    sepv = np.asarray(sep)    sorted_indices = np.argpartition(-w, len(w) - 1)    sorted_indices = sorted_indices[np.argsort(-w[sorted_indices])]    return w[sorted_indices], sepv[sorted_indices]def apply_threshold(val, sep, mincsize, threshold):    val = np.asarray(val)    sep = np.asarray(sep)    idx = val >= threshold    # idx[0:(mincsize-1)] = True    idx[:mincsize] = True    return val[idx], sep[idx]# # @njit# def apply_threshold(val, sep, mincsize, threshold):#     idx = np.where(val >= threshold)[0]#     idx = np.concatenate((idx, np.arange(mincsize)))#     idx = np.unique(idx)#     return val[idx], sep[idx]def greedy_sortsep_v(vertices, sets, W):    retval = [greedy_sortsep(v, s, W) for v, s in zip(vertices, sets)]    ranked_values = [x[0] for x in retval if x[0].size > 0]    ranked_seps = [x[1] for x in retval if x[1].size > 0]    return ranked_values, ranked_seps# def sumsquares_gen(M_squared, v, clq, threshold, min_clique_size, max_clique_size, cachesize):##     """##     M similarity matrix##     v vector of outstanding nodes##     clq clique##     ct_control parameters for the clique expansion algorithm##     """##     clq = tuple(clq)#     csz = len(clq)#     vn = len(v)##     if csz < max_clique_size:#         facets = list()#         facets = [clq]#     else:#         facets = list(itertools.combinations(clq, csz-1))##     block_rows = len(facets)##     # the_vs = np.sort(np.tile(v, block_rows)) # nodes in order#     the_vs = np.repeat(v, block_rows)#     the_fs = facets * vn # facets as they are generated##     ranked_values, ranked_seps = greedy_sortsep_v(the_vs, the_fs, M_squared)##     ranked_values_thr, ranked_seps_thr =  apply_threshold_v(ranked_values, ranked_seps, min_clique_size, threshold)##     # selector = np.tile( list(range(1,block_rows+1)), vn)#     gains = np.array([sum(vals) for vals in ranked_values_thr if vals is not None])##     selector = np.repeat(np.arange(1, block_rows + 1), len(v))##     idx = selector <= cachesize#     nodes = the_vs[idx]#     gains = gains[idx] if len(gains) > 0 else np.array([])#     seps = [frozenset(sep) for sep in ranked_seps_thr if sep is not None]##     return nodes.tolist(), gains.tolist(), seps#def sumsquares_gen(M_squared, v, clq, threshold, min_clique_size, max_clique_size, cachesize):    csz = len(clq)    # Generate facets based on clique size    if csz < max_clique_size:        facets = [clq]    else:        facets = list(combinations(clq, csz - 1))    block_rows = len(facets)    # Create repeated facets and nodes    the_vs = np.repeat(v, block_rows)    the_fs = facets * len(v)    # Compute sorted values and separators    ranked_values, ranked_seps = greedy_sortsep_v(the_vs, the_fs, M_squared)    # Apply thresholding    ranked_values_thr, ranked_seps_thr = apply_threshold_v(ranked_values, ranked_seps, min_clique_size, threshold)    # Compute gains    gains = np.array([np.sum(vals) for vals in ranked_values_thr])    # Filter by cache size    selector = np.repeat(np.arange(1, block_rows + 1), len(v))    valid_indices = selector <= cachesize    nodes = the_vs[valid_indices]    gains = gains[valid_indices]    seps = [frozenset(sep) for sep in ranked_seps_thr if sep is not None]    return nodes.tolist(), gains.tolist(), seps#def apply_threshold_v(ranked_values, ranked_seps, mincsize, threshold):    filtered = [apply_threshold(vals, sep, mincsize, threshold) for vals, sep in zip(ranked_values, ranked_seps)]    # Separate filtered values into two lists or return empty lists if filtering removed all values    if filtered:        ranked_values, ranked_seps = zip(*filtered)    else:        ranked_values, ranked_seps = [], []    return ranked_values, ranked_seps