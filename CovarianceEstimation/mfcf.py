# -*- coding: utf-8 -*-"""Spyder EditorThis is a temporary script file."""import pandas as pdimport numpy as npimport gain_table as gtabimport mathimport gain_functions as gfclass MFCF:    def __init__(self, Cov, min_clique_size, max_clique_size, coordination_number, threshold, gain_function = gf.sumsquares_gen):        self.Cov = Cov        self.C = np.square(pd.DataFrame(self.Cov).corr()).to_numpy()        self.C_squared = self.C * self.C        self.gain_function = gain_function        self.ctl = {'min_clique_size': int(min_clique_size),                    'max_clique_size': int(max_clique_size),                    'coordination_number': int(coordination_number),                    'cachesize': 3,                    'threshold': float(threshold),                    'drop_sep': True}        self.threshold = self.ctl.get('threshold', 0.0)        self.min_clique_size = self.ctl.get('min_clique_size', 4)        self.max_clique_size = self.ctl.get('max_clique_size', 4)        self.cachesize = self.ctl.get('cachesize',min(4, min_clique_size))    def first_clique(self, C, min_size):        r, c = np.nonzero(C <= C.mean())        C1 = C.copy()        C1[r, c] = 0        sums = C1.sum(axis=0)        cand = np.argsort(-sums)        clq = np.nonzero(cand < min_size)        return clq[0]    def mfcf(self):        ctl_drop_sep = self.ctl['drop_sep']        cliques = []        separators = []        q, p = self.C.shape        outstanding_nodes = list(range(0, p))        first_cl = self.first_clique(self.C, self.ctl['min_clique_size'])        first_cl = frozenset(first_cl)        cliques.append(first_cl)        outstanding_nodes = [node for node in outstanding_nodes if node not in first_cl]        peo = [node for node in first_cl]        gt_nodes, gt_gains, gt_separators = self.gain_function(self.C_squared, outstanding_nodes, first_cl, self.threshold, self.min_clique_size, self.max_clique_size, self.cachesize)        gt_cliques = [first_cl] * len(gt_gains)        while len(outstanding_nodes) > 0:            print(len(outstanding_nodes))            # get maximum gain            the_gain = np.nanmax(gt_gains)            idx = np.nanargmax(gt_gains)            clique_extension = False            # case isolated clique, pick up outstanding node and add isolated clq            if the_gain <= 0 :                # pick up first vertex                the_node = outstanding_nodes.pop(0)                the_sep = []                parent_clique = []                new_clique = frozenset([the_node])            # case gain with a clique            else:                the_node = gt_nodes[idx]                the_sep = gt_separators[idx]                parent_clique = gt_cliques[idx]                clique_extension = True                new_clique = frozenset(the_sep | {the_node})            peo.append(the_node)            outstanding_nodes = [x for x in outstanding_nodes if x != the_node]            if the_gain <= 0:                cliques.append(new_clique)            elif len(new_clique) <= len(parent_clique):                cliques.append(new_clique)                separators.append(the_sep)            else:                cliques.append(new_clique)                cliques.remove(parent_clique)            # if len(outstanding_nodes) == 0:            #            #     break            nodes, gains, seps = self.gain_function(self.C_squared, outstanding_nodes, new_clique, self.threshold, self.min_clique_size, self.max_clique_size, self.cachesize)            add_cliques = [new_clique] * len(gains)            gt_gains.extend(gains)            gt_cliques.extend(add_cliques)            gt_separators.extend(seps)            gt_nodes.extend(nodes)            gt_gains = [gain if node != the_node else math.nan for gain, node in zip(gt_gains, gt_nodes)]            if ctl_drop_sep:                gt_gains = [gain if sep != the_sep else math.nan for gain, sep in zip(gt_gains, gt_separators)]            if clique_extension:                # In case of clique extension remove the old clique                gt_gains = [gain if clq != parent_clique else math.nan for gain, clq in zip(gt_gains, gt_cliques)]        gt = gtab.gain_table()        gt.nodes = gt_nodes        gt.cliques = gt_cliques        gt.separators = gt_separators        gt.gains = gt_gains        return cliques, separators, peo, gt    def logo(self, cliques, separators):        J = np.zeros(self.C.shape)        for clq in cliques:            clqt = tuple(clq)            J[np.ix_(clqt, clqt)] += np.linalg.inv(self.Cov[np.ix_(clqt, clqt)])        for sep in separators:            sept = tuple(sep)            J[np.ix_(sept, sept)] -= np.linalg.inv(self.Cov[np.ix_(sept, sept)])        return J    def get_mfcf(self):        import cProfile        import pstats        import io        from pstats import SortKey        # Creating profile object        ob = cProfile.Profile()        ob.enable()        #########        cliques, separators, _, _ = self.mfcf()        #########        ob.disable()        sec = io.StringIO()        sortby = SortKey.CUMULATIVE        ps = pstats.Stats(ob, stream=sec).sort_stats(sortby)        ps.print_stats()        print(sec.getvalue())        return cliques, separators    def get_precision_matrix(self):        cliques, seps = self.get_mfcf()  # Change min_clique_size and max_clique_size to switch from TMFG to undirected graphical models with different clique size.        J = self.logo(cliques, seps)        return J